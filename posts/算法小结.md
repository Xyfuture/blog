---
title: 算法小结
date: 2020-03-09 16:22:02
tags:
 - 算法
 - algorithm
categories:
 - 程序设计思维
---

#  dijkstra 

迪杰斯特拉算法是用于计算单点最短路,并且要求图是无负边权的.

## 算法思路

从一个点开始,记录一个到其他所有点的数组,从这个数组中取出最近的一个点,更新那个数组,然后重复那个数组,每次取最短的点然后更新,直到所有点都被遍历.

### 复杂度

节点数 v 边数 e

**邻接表**

$O(v^2)$ ($O(v^2+e)$)

因为一共更新了n个点,每个点取的时候首先找最短的点(n的复杂度),同时取完了会找一遍所有的边

**邻接矩阵**

$O(v^2)$

# Prime

# Kruskal

# SPFA

# Floyd

# BFS

BFS啥都能干...

## 算法思路

首先有一个**vis数组**,这个数组用来记录走过的点,然后开一个队列用来记录访问的元素.好了现在开始BFS,先将原点的vis标记,将这个点加入到队列,从队列中取出这个点,对这个点操作,然后访问这个点所有的邻接点,将没有被标记的点标记加入到队列中,重复队列的循环,直到队列空.

## 复杂度

顶点数 v 边数 e

**邻接表**

$O(v+e)$

每个点都被访问一次,访问时候v^2走一个函数,所有点就算v,然后有一个加入队列的for循环,这个循环总的合起来就是e,因此时v+e

**邻接矩阵**

$O(v^2)$

两个for 都是v

**Question**

邻接表和邻接矩阵的复杂度看着似乎有点问题,不是一个量级,但是你要注意到e最大是v^2,所以还是一个量级的

# DFS

## 算法思想

DFS是递归的方法,首先标记自己,然后搜索所有没有被标记的点,对他们进行DFS,不能继续搜索就返回到上一级,直到所有都返回

## 复杂度

和BFS相同

**邻接表**

$O(v+e)$

## 注意点

DFS和BFS都需要注意剪枝的问题,不符合条件的情况一定不要继续访问,主要就是vis数组要标记好

参考CSP卖菜问题